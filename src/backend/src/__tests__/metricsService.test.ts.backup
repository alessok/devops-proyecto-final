import {
  register,
  httpRequestsTotal,
  httpRequestDuration,
  activeConnections,
  databaseConnectionPool,
  businessMetrics
} from '../services/metricsService';
import client from 'prom-client';

describe('MetricsService', () => {
  afterEach(() => {
    // Clear all metrics after each test
    register.clear();
  });

  describe('Metrics Registration', () => {
    it('should have a valid registry', () => {
      expect(register).toBeInstanceOf(client.Registry);
    });

    it('should have default labels set', () => {
      const metrics = register.getMetricsAsJSON();
      expect(register).toBeDefined();
    });
  });

  describe('HTTP Metrics', () => {
    it('should increment HTTP requests counter', () => {
      httpRequestsTotal.inc({ method: 'GET', route: '/products', status_code: '200' });
      httpRequestsTotal.inc({ method: 'POST', route: '/products', status_code: '201' });

      const metrics = register.getSingleMetric('http_requests_total');
      expect(metrics).toBeDefined();
    });

    it('should record HTTP request duration', () => {
      const endTimer = httpRequestDuration.startTimer({ method: 'GET', route: '/products' });
      
      // Simulate some processing time
      setTimeout(() => {
        endTimer({ status_code: '200' });
      }, 10);

      const metrics = register.getSingleMetric('http_request_duration_seconds');
      expect(metrics).toBeDefined();
    });

    it('should observe HTTP request duration directly', () => {
      httpRequestDuration.observe(
        { method: 'GET', route: '/products', status_code: '200' },
        0.5
      );

      const metrics = register.getSingleMetric('http_request_duration_seconds');
      expect(metrics).toBeDefined();
    });
  });

  describe('Connection Metrics', () => {
    it('should set active connections gauge', () => {
      activeConnections.set(10);
      activeConnections.inc();
      activeConnections.dec();

      const metrics = register.getSingleMetric('active_connections');
      expect(metrics).toBeDefined();
    });

    it('should set database connection pool size', () => {
      databaseConnectionPool.set(20);

      const metrics = register.getSingleMetric('database_connection_pool_size');
      expect(metrics).toBeDefined();
    });
  });

  describe('Business Metrics', () => {
    it('should update total users metric', () => {
      businessMetrics.totalUsers.set(100);
      businessMetrics.totalUsers.inc();

      const metrics = register.getSingleMetric('total_users');
      expect(metrics).toBeDefined();
    });

    it('should update total products metric', () => {
      businessMetrics.totalProducts.set(500);
      businessMetrics.totalProducts.inc(5);

      const metrics = register.getSingleMetric('total_products');
      expect(metrics).toBeDefined();
    });

    it('should update low stock products metric', () => {
      businessMetrics.lowStockProducts.set(15);

      const metrics = register.getSingleMetric('low_stock_products');
      expect(metrics).toBeDefined();
    });

    it('should update total categories metric', () => {
      businessMetrics.totalCategories.set(10);

      const metrics = register.getSingleMetric('total_categories');
      expect(metrics).toBeDefined();
    });
  });

  describe('Metrics Export', () => {
    it('should export metrics in Prometheus format', async () => {
      // Set some sample data
      httpRequestsTotal.inc({ method: 'GET', route: '/test', status_code: '200' });
      activeConnections.set(5);
      businessMetrics.totalUsers.set(50);

      const metrics = await register.metrics();
      
      expect(typeof metrics).toBe('string');
      expect(metrics).toContain('http_requests_total');
      expect(metrics).toContain('active_connections');
      expect(metrics).toContain('total_users');
    });

    it('should export metrics as JSON', async () => {
      httpRequestsTotal.inc({ method: 'POST', route: '/test', status_code: '201' });
      businessMetrics.totalProducts.set(25);

      const metricsJSON = await register.getMetricsAsJSON();
      
      expect(Array.isArray(metricsJSON)).toBe(true);
      expect(metricsJSON.length).toBeGreaterThan(0);
    });
  });

  describe('Multiple Label Combinations', () => {
    it('should handle different HTTP method combinations', () => {
      const methods = ['GET', 'POST', 'PUT', 'DELETE'];
      const routes = ['/products', '/users', '/categories'];
      const statusCodes = ['200', '201', '400', '404', '500'];

      methods.forEach(method => {
        routes.forEach(route => {
          statusCodes.forEach(statusCode => {
            httpRequestsTotal.inc({ method, route, status_code: statusCode });
          });
        });
      });

      const metrics = register.getSingleMetric('http_requests_total');
      expect(metrics).toBeDefined();
    });

    it('should handle concurrent metric updates', async () => {
      // Simulate concurrent requests
      for (let i = 0; i < 100; i++) {
        httpRequestsTotal.inc({ method: 'GET', route: '/products', status_code: '200' });
        activeConnections.inc();
        businessMetrics.totalUsers.inc();
      }

      // Decrease connections
      for (let i = 0; i < 50; i++) {
        activeConnections.dec();
      }

      const metrics = await register.getMetricsAsJSON();
      expect(metrics.length).toBeGreaterThan(0);
    });
  });

  describe('Histogram Buckets', () => {
    it('should distribute values across histogram buckets', () => {
      const durations = [0.05, 0.2, 0.8, 1.5, 3.0, 7.0];
      
      durations.forEach(duration => {
        httpRequestDuration.observe(
          { method: 'GET', route: '/test', status_code: '200' },
          duration
        );
      });

      const metrics = register.getSingleMetric('http_request_duration_seconds');
      expect(metrics).toBeDefined();
    });
  });

  describe('Error Handling', () => {
    it('should handle metrics with missing labels gracefully', () => {
      // This should not throw an error
      expect(() => {
        httpRequestsTotal.inc({ method: 'GET' }); // Missing required labels
      }).not.toThrow();
    });

    it('should handle negative gauge values', () => {
      activeConnections.set(-5);
      
      const metrics = register.getSingleMetric('active_connections');
      expect(metrics).toBeDefined();
    });
  });
});
